import attr
import copy
import pathlib
import re
import typing
from collections.abc import Iterable

import epcpm.pm_helper
import epcpm.sunspecmodel
import epyqlib.utils.general

builders = epyqlib.utils.general.TypeMap()
specific_builders = epyqlib.utils.general.TypeMap()
enumeration_builders = epyqlib.utils.general.TypeMap()

AUTO_GEN_LINE = '/* Generated by "sunspectointerface.py" */\n\n'


@attr.s
class OutputPoint:
    type = attr.ib()
    name = attr.ib()
    size = attr.ib()
    default_value = attr.ib()
    original_name = attr.ib()
    model_id = attr.ib()
    read_write = attr.ib()


def flatten_list(list_of_lists: typing.List) -> typing.List:
    """
    Given a list of lists, flatten into a single list.

    Args:
        list_of_lists: list of lists to flatten

    Returns:
        list: individual list from the given list of lists
    """
    for sublist in list_of_lists:
        if isinstance(sublist, Iterable) and not isinstance(sublist, (str, bytes)):
            yield from flatten_list(sublist)
        else:
            yield sublist


def get_point_name_prefix(
    sunspec_id: epcpm.pm_helper.SunSpecSection, model_id: int
) -> str:
    """
    Return partial point name for use in C code.

    Args:
        sunspec_id: SunSpec section internal identifier
        model_id: model ID

    Returns:
        point name prefix
    """
    return f"SUNSPEC{sunspec_id.value}_MODEL{model_id}_"


def get_full_point_name(
    sunspec_id: epcpm.pm_helper.SunSpecSection, model_id: int, point_name: str
) -> str:
    """
    Return the full point name for use in C code.

    Args:
        sunspec_id: SunSpec section internal identifier
        model_id: model ID
        point_name: point name to be used as part of a full point name

    Returns:
        full point name
    """
    point_name_prefix = get_point_name_prefix(sunspec_id, model_id)
    return f"{point_name_prefix}{point_name}"


# Conversion of SunSpec types to C types.
sunspec_types = {
    "uint16": "uint16_t",
    "enum16": "uint16_t",
    "int16": "int16_t",
    "uint32": "sunsU32",
    "int32": "sunsS32",
    "uint64": "sunsU64",
    "string": "PackedString",
    "bitfield16": "sunsU16",
    "bitfield32": "sunsU32",
    "sunssf": "sunssf",
    "acc32": "acc32",
    "acc64": "acc64",
    "pad16": "pad16",
}


def export(
    c_path: pathlib.Path,
    h_path: pathlib.Path,
    sunspec_model: epyqlib.attrsmodel.Model,
    sunspec_id: epcpm.pm_helper.SunSpecSection,
    skip_sunspec: bool = False,
) -> None:
    """
    Generate the SunSpec model data interface .c and .h files.

    Args:
        c_path: path and filename for .c file
        h_path: path and filename for .h file
        sunspec_model: SunSpec model
        sunspec_id: SunSpec section internal identifier
        skip_sunspec: skip output of the generated files

    Returns:

    """
    builder = builders.wrap(
        wrapped=sunspec_model.root,
        parameter_uuid_finder=sunspec_model.node_from_uuid,
        skip_sunspec=skip_sunspec,
        sunspec_id=sunspec_id,
        c_path=c_path,
        h_path=h_path,
    )
    c_path.parent.mkdir(parents=True, exist_ok=True)
    builder.gen()

    builder = specific_builders.wrap(
        wrapped=sunspec_model.root,
        parameter_uuid_finder=sunspec_model.node_from_uuid,
        skip_sunspec=skip_sunspec,
        sunspec_id=sunspec_id,
        c_path=c_path,
        h_path=h_path,
    )
    c_path.parent.mkdir(parents=True, exist_ok=True)
    builder.gen()


@builders(epcpm.sunspecmodel.Root)
@attr.s
class Root:
    """Interface generator for the SunSpec Root class."""

    wrapped = attr.ib()
    parameter_uuid_finder = attr.ib()
    skip_sunspec = attr.ib()
    sunspec_id = attr.ib(default=None)
    c_path = attr.ib(default=None)
    h_path = attr.ib(default=None)

    def gen(self) -> None:
        """
        Interface generator for the SunSpec Root class.

        Returns:

        """
        h_content = []
        model_list = []
        model_points = []
        for child in self.wrapped.children:
            if not isinstance(child, epcpm.sunspecmodel.Model):
                continue

            builder = builders.wrap(
                wrapped=child,
                parameter_uuid_finder=self.parameter_uuid_finder,
                sunspec_id=self.sunspec_id,
                c_path=self.c_path,
                h_path=self.h_path,
                skip_sunspec=self.skip_sunspec,
            )

            h_built, model_id, model_points_built = builder.gen()
            h_content.extend(h_built)
            model_list.append(model_id)
            model_points.append(model_points_built)

        (
            longest_point_name_len,
            total_rw_registers,
            total_addresses,
        ) = self._pre_calculate_model_values(model_points)
        h_lines = self._generate_h_lines(
            h_content, model_list, model_points, total_rw_registers, total_addresses
        )
        c_lines = self._generate_c_lines(
            model_list,
            model_points,
            longest_point_name_len,
            total_rw_registers,
            total_addresses,
        )

        # Output the overall .c file.
        with self.c_path.open("w", newline="\n") as f:
            for c_line in c_lines:
                f.write(c_line)

        # Output the overall .h file.
        with self.h_path.open("w", newline="\n") as f:
            for h_line in h_lines:
                f.write(h_line)

    def _pre_calculate_model_values(
        self, model_points: typing.List[typing.List[OutputPoint]]
    ) -> typing.Tuple[int, int, int]:
        """
        Calculate values from model points used by interface generation.
            longest point name length
            total RW registers
            total addresses

        Args:
            model_points: list of a list of output points

        Returns:
            longest_point_name_len, total_rw_registers, total_addresses
        """
        longest_point_name_len = 0
        total_rw_registers = 0
        # Initialize total addresses by accounting for the 'SunS' characters length.
        total_addresses = epcpm.pm_helper.SUNS_LENGTH
        for block_points in model_points:
            for point in block_points:
                total_addresses += point.size
                if point.read_write == "RW":
                    total_rw_registers += point.size
                if point.type == "SunspecModelHeader":
                    # Skip header block
                    continue
                if point.size > 1:
                    for point_size_index in range(point.size):
                        point_name_length = len(
                            get_full_point_name(
                                self.sunspec_id, point.model_id, point.name
                            )
                        ) + len(str(point_size_index))
                else:
                    point_name_length = len(
                        get_full_point_name(self.sunspec_id, point.model_id, point.name)
                    )

                # Calculate the longest point name length.
                if (
                    point.read_write == "RW"
                    and point_name_length > longest_point_name_len
                ):
                    longest_point_name_len = point_name_length

        return longest_point_name_len, total_rw_registers, total_addresses

    def _generate_h_lines(
        self,
        h_content: typing.List[str],
        model_list: typing.List[int],
        model_points: typing.List[typing.List[OutputPoint]],
        total_rw_registers: int,
        total_addresses: int,
    ) -> typing.List[str]:
        """
        Generate the overall .h file.

        Args:
            h_content: generated content to be included with the overall output
            model_list: list of model ID's
            model_points: list of a list of output points
            total_rw_registers: total RW registers
            total_addresses: total addresses

        Returns:
            list of strings for output in .h file
        """
        include_guard = f"__SUNSPEC{self.sunspec_id.value}_INTERFACE_GEN_H__"
        h_lines = [f"#ifndef {include_guard}\n#define {include_guard}\n\n\n"]
        h_lines.extend([AUTO_GEN_LINE])
        h_lines.extend(
            [
                '#include "sunspec.h"\n',
                '#include "interface.h"\n',
                "\n\n",
            ]
        )

        h_lines.extend(h_content)

        h_lines.extend(["/*\n Top-level interface structure\n*/\n"])

        h_lines.extend(
            [
                "typedef struct\n{\n",
                "    uint16_t SunS_ID_hi;\n",
                "    uint16_t SunS_ID_lo;\n",
            ]
        )

        for model in model_list:
            h_lines.extend(
                [f"    Sunspec{self.sunspec_id.value}Model{model} model{model};\n"]
            )

        sunspec_hi, sunspec_lo = epcpm.pm_helper.get_sunspec_starting_register_values(
            self.sunspec_id
        )
        h_lines.extend(
            [
                "    uint16_t ModelEndID;\n",
                "    uint16_t ModelEndLen;\n",
                f"}} SunSpec{self.sunspec_id.value}Interface;\n\n",
                f"#define SUNSPEC{self.sunspec_id.value}INTERFACE_DEFAULTS(...) \\\n{{ \\\n",
                f"    .SunS_ID_hi = {sunspec_hi}, \\\n",
                f"    .SunS_ID_lo = {sunspec_lo}, \\\n",
            ]
        )

        for model in model_list:
            h_lines.extend(
                [
                    f"    .model{model} = SUNSPEC{self.sunspec_id.value}MODEL{model}_DEFAULTS(), \\\n"
                ]
            )

        h_lines.extend(
            [
                "    .ModelEndID = 0xFFFF, \\\n"
                "    .ModelEndLen = 0, \\\n"
                "    __VA_ARGS__ \\\n"
                "}\n\n",
            ]
        )

        h_lines.extend(["//Read/write register index enumerations:\n"])
        h_lines.extend(["enum{\n"])

        for block_points in model_points:
            for point in block_points:
                if point.type == "SunspecModelHeader":
                    # Skip header block
                    continue
                point_name = get_full_point_name(
                    self.sunspec_id, point.model_id, point.name
                )
                if point.size > 1:
                    for point_size_index in range(point.size):
                        h_lines.extend([f"    {point_name}{point_size_index},\n"])
                else:
                    h_lines.extend([f"    {point_name},\n"])

        h_lines.extend([f"    SUNSPEC{self.sunspec_id.value}_REG_LEN\n}};\n\n"])

        for model_id in model_list:
            h_lines.extend(
                [f"void sunspec{self.sunspec_id.value}Model{model_id}Init(void);\n"]
            )

        h_lines.extend(
            f"\nextern SunSpec{self.sunspec_id.value}Interface sunspec{self.sunspec_id.value}Interface;\n"
        )
        h_lines.extend(
            f"extern ModbusReg sunspec{self.sunspec_id.value}Regs[SUNSPEC{self.sunspec_id.value}_REG_LEN];\n"
        )
        h_lines.extend(
            f"extern ModbusRegRW sunspec{self.sunspec_id.value}RegsRw[{total_rw_registers}];\n"
        )
        h_lines.extend(
            f"extern SunspecModel sunspec{self.sunspec_id.value}ModelList[{len(model_list)}];\n"
        )
        h_lines.extend(
            f"extern ModbusReg * const sunspec{self.sunspec_id.value}AddrRegMap[{total_addresses}];\n"
        )

        h_lines.extend([f"\n#endif //{include_guard}\n"])

        return h_lines

    def _generate_c_lines(
        self,
        model_list: typing.List[int],
        model_points: typing.List[typing.List[OutputPoint]],
        longest_point_name_len: int,
        total_rw_registers: int,
        total_addresses: int,
    ) -> typing.List[str]:
        """
        Generate the overall .c file.

        Args:
            model_list: list of model ID's
            model_points: list of a list of output points
            longest_point_name_len: longest point name length
            total_rw_registers: total RW registers
            total_addresses: total addresses

        Returns:
            list of strings for output in .c file
        """
        c_lines = [f'#include "sunspec{self.sunspec_id.value}InterfaceGen.h"\n\n']

        for model_id in model_list:
            c_lines.extend(
                [f'#include "sunspec{self.sunspec_id.value}InterfaceGen{model_id}.h"\n']
            )

        c_lines.extend(
            [
                "\n\n",
                AUTO_GEN_LINE,
                f'#pragma DATA_SECTION(sunspec{self.sunspec_id.value}Interface, "SunSpecInterfaceData")\n',
                f"SunSpec{self.sunspec_id.value}Interface sunspec{self.sunspec_id.value}Interface = SUNSPEC{self.sunspec_id.value}INTERFACE_DEFAULTS();\n\n",
            ]
        )

        c_lines.extend(
            [
                f'#pragma DATA_SECTION(sunspec{self.sunspec_id.value}RegsRw, "SunSpecInterfaceData")\n',
                f"ModbusRegRW sunspec{self.sunspec_id.value}RegsRw[{total_rw_registers}] =\n",
                "{\n",
            ]
        )

        point_index = 0
        for block_points in model_points:
            for point in block_points:
                if point.read_write == "RW":
                    sign = "true" if point.type == "int16_t" else "false"
                    point_name = get_full_point_name(
                        self.sunspec_id, point.model_id, point.name
                    )
                    set_name = f"&set{point_name}"
                    if point.size > 1:
                        for point_size_index in range(point.size):
                            point_name_with_index = f"{point_name}{point_size_index}"

                            if point_size_index > 0:
                                set_name = "NULL"
                            c_lines.extend(
                                [
                                    f"    [{point_index}] = MODBUS_REGISTER_RW_DEFAULTS(/* {point_name_with_index: <{longest_point_name_len}} */ .sign = {sign}, .set = {set_name}),\n"
                                ]
                            )
                            point_index += 1
                    else:
                        c_lines.extend(
                            [
                                f"    [{point_index}] = MODBUS_REGISTER_RW_DEFAULTS(/* {point_name: <{longest_point_name_len}} */ .sign = {sign}, .set = {set_name}),\n"
                            ]
                        )
                        point_index += 1
        c_lines.extend(
            [
                "};\n\n",
            ]
        )

        c_lines.extend(
            [
                f'#pragma DATA_SECTION(sunspec{self.sunspec_id.value}Regs, "SunSpecInterfaceData")\n',
                f"ModbusReg sunspec{self.sunspec_id.value}Regs[] =\n",
                "{\n",
            ]
        )
        register_index = 0
        rw_index = 0
        # Initialize address index by accounting for the 'SunS' characters length.
        addr_index = epcpm.pm_helper.SUNS_LENGTH
        for block_points in model_points:
            for point in block_points:
                point_name = get_full_point_name(
                    self.sunspec_id, point.model_id, point.name
                )
                first_reg = f"&sunspec{self.sunspec_id.value}Regs[{register_index}]"

                if point.type == "pad16":
                    getter = "NULL"
                else:
                    getter = f"&get{point_name}"

                if point.type == "SunspecModelHeader":
                    addr_index += point.size
                    continue
                if point.size > 1:
                    for point_size_index in range(point.size):
                        point_name_with_index = f"{point_name}{point_size_index}"
                        if point.read_write == "RW":
                            setter = f", .w = &sunspec{self.sunspec_id.value}RegsRw[{rw_index}]"
                            rw_index += 1
                        else:
                            setter = ""
                        if point_size_index > 0:
                            getter = "NULL"
                        c_lines.extend(
                            [
                                f"    [{register_index}] = MODBUS_REGISTER_DEFAULTS(/* {point_name_with_index: <{longest_point_name_len}} */ .addr = {addr_index}, .firstReg = {first_reg}, .size = {point.size}, .get = {getter}{setter}),\n"
                            ]
                        )
                        register_index += 1
                        addr_index += 1

                else:
                    if point.read_write == "RW":
                        setter = (
                            f", .w = &sunspec{self.sunspec_id.value}RegsRw[{rw_index}]"
                        )
                        rw_index += 1
                    else:
                        setter = ""
                    c_lines.extend(
                        [
                            f"    [{register_index}] = MODBUS_REGISTER_DEFAULTS(/* {point_name: <{longest_point_name_len}} */ .addr = {addr_index}, .firstReg = {first_reg}, .size = {point.size}, .get = {getter}{setter}),\n"
                        ]
                    )
                    register_index += 1
                    addr_index += 1
        c_lines.extend(
            [
                "};\n\n",
            ]
        )

        c_lines.extend(
            [
                f"ModbusReg * const sunspec{self.sunspec_id.value}AddrRegMap[{total_addresses}] =\n",
                "{\n",
            ]
        )
        # Initialize register index by accounting for the 'SunS' characters length.
        register_index = epcpm.pm_helper.SUNS_LENGTH
        point_index = 0
        for block_points in model_points:
            for point in block_points:
                if point.type == "SunspecModelHeader":
                    register_index += point.size
                else:
                    for point_size_index in range(point.size):
                        c_lines.extend(
                            [
                                f"    [{register_index}] = &sunspec{self.sunspec_id.value}Regs[{point_index}],\n"
                            ]
                        )
                        point_index += 1
                        register_index += 1
        c_lines.extend(
            [
                "};\n\n",
            ]
        )

        c_lines.extend(
            [
                f"SunspecModel sunspec{self.sunspec_id.value}ModelList[] =\n",
                "{\n",
            ]
        )
        for model_id in model_list:
            c_lines.extend(
                [
                    f"    {{.num = {model_id}, .data = &sunspec{self.sunspec_id.value}Interface.model{model_id}, .init = &sunspec{self.sunspec_id.value}Model{model_id}Init}},\n"
                ]
            )
        c_lines.extend(
            [
                "};\n\n",
            ]
        )

        return c_lines


@builders(epcpm.sunspecmodel.Model)
@attr.s
class Model:
    """Interface generator for the SunSpec Model class."""

    wrapped = attr.ib()
    parameter_uuid_finder = attr.ib()
    sunspec_id = attr.ib()
    skip_sunspec = attr.ib()
    c_path = attr.ib(default=None)
    h_path = attr.ib(default=None)

    def gen(self) -> typing.Tuple[typing.List[str], int, typing.List[OutputPoint]]:
        """
        Interface generator for the SunSpec Model class.

        Returns:
            list of strings, int, list of OutputPoint: output .h lines, model ID, list of model OutputPoint's
        """
        points = []
        h_enum_lines = []
        h_enum_default_enumerator_dict = dict()
        model_types = ["Header", "Fixed Block", "Repeating Block"]
        child_model_types = zip(enumerate(self.wrapped.children), model_types)
        for (i, child), model_type in child_model_types:
            builder = builders.wrap(
                wrapped=child,
                model_id=self.wrapped.id,
                parameter_uuid_finder=self.parameter_uuid_finder,
                sunspec_id=self.sunspec_id,
            )
            built_points = builder.gen()
            points.extend(built_points)

            add_padding = epcpm.pm_helper.add_padding_to_block(
                child, self.sunspec_id, self.wrapped.id, model_type
            )

            if add_padding:
                pad_point = OutputPoint(
                    type="pad16",
                    name="Pad",
                    size=1,
                    default_value="SUNSPEC_PAD_VAL",
                    original_name="Pad",
                    model_id=self.wrapped.id,
                    read_write="R",
                )

                points.append(pad_point)

            enumeration_builder = enumeration_builders.wrap(
                wrapped=child,
                model_id=self.wrapped.id,
                parameter_uuid_finder=self.parameter_uuid_finder,
                sunspec_id=self.sunspec_id,
            )
            h_enum_lines_built, default_enumerator_dict = enumeration_builder.gen()
            h_enum_lines.extend(h_enum_lines_built)
            h_enum_default_enumerator_dict.update(default_enumerator_dict)

        h_lines = []
        h_lines.extend([f"/*\nModel {self.wrapped.id}\n*/\n"])

        h_lines.extend(h_enum_lines)

        struct_name = f"Sunspec{self.sunspec_id.value}Model{self.wrapped.id}"
        h_lines.extend(
            [
                "typedef struct\n{\n",
            ]
        )

        model_size = 0
        for point in points:
            if point.type == "PackedString":
                h_lines.extend([f"    {point.type} {point.name}[{point.size}];\n"])
            else:
                h_lines.extend([f"    {point.type} {point.name};\n"])

            # Since code is already looping through all the points, calculate the model size.
            if point.type != "SunspecModelHeader":
                model_size += point.size

        h_lines.extend(
            [
                f"}} {struct_name};\n\n",
                f"#define {struct_name.upper()}_DEFAULTS(...) \\\n{{ \\\n",
            ]
        )

        for point in points:
            if point.type == "SunspecModelHeader":
                h_lines.extend(
                    [
                        f"    .{point.name} = {{.id = {self.wrapped.id}, .length = {model_size}}}, \\\n"
                    ]
                )
            elif point.type == "PackedString":
                h_lines.extend(
                    [
                        f"    .{point.name} = {{[0 ... {point.size - 1}] = {point.default_value}}}, /*0*/ \\\n"
                    ]
                )
            elif point.original_name in h_enum_default_enumerator_dict:
                # original_name is the name before the "Curve_NN" prefix was applied.
                default_enumerator = h_enum_default_enumerator_dict[point.original_name]
                if default_enumerator.abbreviation:
                    default_enumerator_name_out = default_enumerator.abbreviation
                else:
                    default_enumerator_name_out = default_enumerator.name
                default_value = f"SUNSPEC{self.sunspec_id.value}MODEL{self.wrapped.id}_{point.original_name.upper()}_{default_enumerator_name_out}"
                h_lines.extend([f"    .{point.name} = {default_value}, \\\n"])
            else:
                h_lines.extend([f"    .{point.name} = {point.default_value}, \\\n"])

        h_lines.extend(
            [
                "    __VA_ARGS__ \\\n" "}\n\n",
            ]
        )

        return h_lines, self.wrapped.id, points


@builders(epcpm.sunspecmodel.HeaderBlock)
@attr.s
class HeaderBlock:
    """Interface generator for the SunSpec HeaderBlock class."""

    wrapped = attr.ib()
    model_id = attr.ib()
    repeating_block_reference = attr.ib(default=None)
    parameter_uuid_finder = attr.ib(default=None)
    sunspec_id = attr.ib(default=None)
    is_table = attr.ib(default=False)
    fixed_block_reference = attr.ib(default=None, type=epcpm.sunspecmodel.FixedBlock)

    def gen(self) -> typing.List[OutputPoint]:
        """
        Interface generator for the SunSpec HeaderBlock class.

        Returns:
            list of OutputPoint: list containing single header OutputPoint
        """
        header_point = OutputPoint(
            type="SunspecModelHeader",
            name="hdr",
            size=2,
            default_value="",
            original_name="hdr",
            model_id=self.model_id,
            read_write="R",
        )
        return [header_point]


@builders(epcpm.sunspecmodel.TableRepeatingBlockReference)
@attr.s
class TableRepeatingBlockReference:
    """Interface generator for the SunSpec TableRepeatingBlockReference class."""

    wrapped = attr.ib()
    model_id = attr.ib()
    repeating_block_reference = attr.ib(default=None)
    parameter_uuid_finder = attr.ib(default=None)
    sunspec_id = attr.ib(default=None)
    is_table = attr.ib(default=False)
    fixed_block_reference = attr.ib(default=None, type=epcpm.sunspecmodel.FixedBlock)

    def gen(self) -> typing.List[OutputPoint]:
        """
        Interface generator for the SunSpec TableRepeatingBlockReference class.

        Returns:
            list of OutputPoint: list of child OutputPoint's
        """
        builder = builders.wrap(
            wrapped=self.wrapped.original,
            parameter_uuid_finder=self.parameter_uuid_finder,
            model_id=self.model_id,
            is_table=False,
            repeating_block_reference=self.wrapped,
            sunspec_id=self.sunspec_id,
        )

        return builder.gen()


@builders(epcpm.sunspecmodel.FixedBlock)
@attr.s
class FixedBlock:
    """Interface generator for the SunSpec FixedBlock class."""

    wrapped = attr.ib()
    model_id = attr.ib()
    repeating_block_reference = attr.ib(default=None)
    parameter_uuid_finder = attr.ib(default=None)
    sunspec_id = attr.ib(default=None)
    is_table = attr.ib(default=False)
    fixed_block_reference = attr.ib(default=None, type=epcpm.sunspecmodel.FixedBlock)

    def gen(self) -> typing.List[OutputPoint]:
        """
        Interface generator for the SunSpec FixedBlock class.

        Returns:
            list of OutputPoint: list of child OutputPoint's
        """
        point_vals_out = []
        for child in self.wrapped.children:
            builder = builders.wrap(
                wrapped=child,
                parameter_uuid_finder=self.parameter_uuid_finder,
                model_id=self.model_id,
                is_table=False,
                sunspec_id=self.sunspec_id,
            )
            point_vals = builder.gen()
            point_vals_out.append(point_vals)

        return point_vals_out


@builders(epcpm.sunspecmodel.TableRepeatingBlock)
@attr.s
class TableRepeatingBlock:
    """Interface generator for the SunSpec TableRepeatingBlock class."""

    wrapped = attr.ib()
    model_id = attr.ib()
    repeating_block_reference = attr.ib(default=None)
    parameter_uuid_finder = attr.ib(default=None)
    sunspec_id = attr.ib(default=None)
    is_table = attr.ib(default=False)
    fixed_block_reference = attr.ib(default=None, type=epcpm.sunspecmodel.FixedBlock)

    def gen(self) -> typing.List[OutputPoint]:
        """
        Interface generator for the SunSpec TableRepeatingBlock class.

        Returns:
            list of OutputPoint: list of child OutputPoint's
        """
        point_vals_original = []
        point_vals_out = []
        for child in self.wrapped.children:
            builder = builders.wrap(
                wrapped=child,
                parameter_uuid_finder=self.parameter_uuid_finder,
                model_id=self.model_id,
                is_table=False,
                sunspec_id=self.sunspec_id,
            )
            point_vals = builder.gen()
            point_vals_original.append(point_vals)

        for curve_index in range(self.repeating_block_reference.get_num_repeats()):
            point_vals_curve = copy.deepcopy(point_vals_original)
            for point_vals in point_vals_curve:
                point_vals.name = f"Curve_{curve_index + 1:02}_{point_vals.name}"
            point_vals_out.extend(point_vals_curve)

        return point_vals_out


@builders(epcpm.sunspecmodel.TableBlock)
@attr.s
class TableBlock:
    """Interface generator for the SunSpec TableBlock class."""

    wrapped = attr.ib()
    model_id = attr.ib()
    repeating_block_reference = attr.ib(default=None)
    parameter_uuid_finder = attr.ib(default=None)
    sunspec_id = attr.ib(default=None)
    is_table = attr.ib(default=False)
    fixed_block_reference = attr.ib(default=None, type=epcpm.sunspecmodel.FixedBlock)

    def gen(self) -> typing.List[OutputPoint]:
        """
        Interface generator for the SunSpec TableBlock class.

        Returns:
            list of OutputPoint: list of child OutputPoint's
        """
        point_vals_out = []
        for child_index, child in enumerate(self.wrapped.children):
            builder = builders.wrap(
                wrapped=child,
                parameter_uuid_finder=self.parameter_uuid_finder,
                model_id=self.model_id,
                is_table=False,
                sunspec_id=self.sunspec_id,
            )
            points_built = builder.gen()
            # Flatten the built points.
            flat_points = list(flatten_list(points_built))
            for point in flat_points:
                point.name = f"Curve_{child_index + 1:02}_{point.name}"
            point_vals_out.extend(flat_points)

        return point_vals_out


@builders(epcpm.sunspecmodel.TableGroup)
@attr.s
class TableGroup:
    """Interface generator for the SunSpec TableGroup class."""

    wrapped = attr.ib()
    model_id = attr.ib()
    repeating_block_reference = attr.ib(default=None)
    parameter_uuid_finder = attr.ib(default=None)
    sunspec_id = attr.ib(default=None)
    is_table = attr.ib(default=False)

    def gen(self) -> typing.List[OutputPoint]:
        """
        Interface generator for the SunSpec TableGroup class.

        Returns:
            list of OutputPoint: list of child OutputPoint's
        """
        point_vals_out = []
        for child in self.wrapped.children:
            builder = builders.wrap(
                wrapped=child,
                parameter_uuid_finder=self.parameter_uuid_finder,
                model_id=self.model_id,
                is_table=False,
                sunspec_id=self.sunspec_id,
            )
            point_vals = builder.gen()
            point_vals_out.append(point_vals)

        return point_vals_out


@builders(epcpm.sunspecmodel.DataPoint)
@attr.s
class DataPoint:
    """Interface generator for the SunSpec DataPoint class."""

    wrapped = attr.ib()
    model_id = attr.ib()
    is_table = attr.ib()
    parameter_uuid_finder = attr.ib(default=None)
    sunspec_id = attr.ib(default=None)

    def gen(self) -> OutputPoint:
        """
        Interface generator for the SunSpec DataPoint class.

        Returns:
            OutputPoint: OutputPoint for the DataPoint
        """
        size = self.wrapped.size
        default = 0

        if self.wrapped.parameter_uuid is not None:
            parameter = self.parameter_uuid_finder(self.wrapped.parameter_uuid)
            sunspec_type = self.parameter_uuid_finder(self.wrapped.type_uuid).name
            sunspec_parameter_type = sunspec_types[sunspec_type]
            if sunspec_type == "string":
                size = self.wrapped.size

            elif sunspec_type in ["int32", "uint32", "acc32"]:
                hi = int(default) >> 16
                lo = int(default) & 0xFFFF
                default = f"{{.hi = {hi}, .lo = {lo}}}"

            elif sunspec_type == "enum16":
                sunspec_parameter_type = f"Sunspec{self.sunspec_id.value}Model{self.model_id}_{parameter.abbreviation}"

            elif sunspec_type in ["bitfield16", "bitfield32"]:
                sunspec_parameter_type = f"Sunspec{self.sunspec_id.value}Model{self.model_id}_{parameter.abbreviation}_u"

            output_point = OutputPoint(
                type=sunspec_parameter_type,
                name=parameter.abbreviation,
                size=size,
                default_value=default,
                original_name=parameter.abbreviation,
                model_id=self.model_id,
                read_write="R" if parameter.read_only else "RW",
            )
            return output_point

        output_point = OutputPoint(
            type="",
            name="",
            size=size,
            default_value=default,
            original_name="",
            model_id=self.model_id,
            read_write="R",
        )
        return output_point


@builders(epcpm.sunspecmodel.DataPointBitfield)
@attr.s
class DataPointBitfield:
    """Interface generator for the SunSpec DataPointBitfield class."""

    wrapped = attr.ib()
    model_id = attr.ib()
    is_table = attr.ib()
    parameter_uuid_finder = attr.ib(default=None)
    sunspec_id = attr.ib(default=None)

    def gen(self) -> OutputPoint:
        """
        Interface generator for the SunSpec DataPointBitfield class.

        Returns:
            OutputPoint: OutputPoint for the DataPointBitfield
        """
        size = self.wrapped.size
        default = 0

        if self.wrapped.parameter_uuid is not None:
            parameter = self.parameter_uuid_finder(self.wrapped.parameter_uuid)

            bitfield_type = f"Sunspec{self.sunspec_id.value}Model{self.model_id}_{parameter.abbreviation}_u"

            output_point = OutputPoint(
                type=bitfield_type,
                name=parameter.abbreviation,
                size=size,
                default_value=default,
                original_name=parameter.abbreviation,
                model_id=self.model_id,
                read_write="R" if parameter.read_only else "RW",
            )
            return output_point

        output_point = OutputPoint(
            type="",
            name="",
            size=size,
            default_value=default,
            original_name="",
            model_id=self.model_id,
            read_write="R",
        )
        return output_point


@specific_builders(epcpm.sunspecmodel.Root)
@attr.s
class SpecificRoot:
    """Specific model interface generator for the SunSpec Root class."""

    wrapped = attr.ib()
    parameter_uuid_finder = attr.ib()
    skip_sunspec = attr.ib()
    sunspec_id = attr.ib(default=None)
    c_path = attr.ib(default=None)
    h_path = attr.ib(default=None)

    def gen(self) -> None:
        """
        Specific model interface generator for the SunSpec Root class.

        Returns:

        """
        for child in self.wrapped.children:
            if not isinstance(child, epcpm.sunspecmodel.Model):
                continue

            builder = specific_builders.wrap(
                wrapped=child,
                parameter_uuid_finder=self.parameter_uuid_finder,
                sunspec_id=self.sunspec_id,
                c_path=self.c_path,
                h_path=self.h_path,
                skip_sunspec=self.skip_sunspec,
            )
            builder.gen()


@specific_builders(epcpm.sunspecmodel.Model)
@attr.s
class SpecificModel:
    """Specific model interface generator for the SunSpec Model class."""

    wrapped = attr.ib()
    parameter_uuid_finder = attr.ib()
    sunspec_id = attr.ib()
    skip_sunspec = attr.ib()
    c_path = attr.ib(default=None)
    h_path = attr.ib(default=None)

    def gen(self) -> None:
        """
        Specific model interface generator for the SunSpec Model class.

        Returns:

        """
        h_file_name = f"{self.h_path.stem}{self.wrapped.id}{self.h_path.suffix}"
        h_file_path = self.h_path.with_name(h_file_name)
        c_file_name = f"{self.c_path.stem}{self.wrapped.id}{self.c_path.suffix}"
        c_file_path = self.c_path.with_name(c_file_name)

        include_guard = (
            f"SUNSPEC{self.sunspec_id.value}_INTERFACE_GEN_{self.wrapped.id}_H"
        )
        h_lines = [f"#ifndef {include_guard}\n#define {include_guard}\n\n\n"]
        h_lines.extend([AUTO_GEN_LINE])

        c_lines = [
            f'#include "sunspec{self.sunspec_id.value}InterfaceGen.h"\n',
            f'#include "sunspec{self.sunspec_id.value}InterfaceGenTables.h"\n',
            '#include "interfaceBitfieldsGen.h"\n',
            f'#include "sunspec{self.sunspec_id.value}InterfaceGen{self.wrapped.id}.h"\n',
            f'#include "sunspec{self.sunspec_id.value}Model{self.wrapped.id}.h"\n',
            "\n/* Basic Types */\n",
            '#include "IQmathLib.h"\n',
            "\n/* Control */\n",
            '#include "powerConversionControl.h"\n',
            '#include "phaseConfigDetect.h"\n',
            '#include "referenceHandler.h"\n',
            '#include "topLevelControl.h"\n',
            "\n/* Supervisor */\n",
            '#include "gridMonitor.h"\n',
            '#include "hardware.h"\n',
            '#include "protections.h"\n',
            '#include "sunspecRefs.h"\n',
            "\n/* Drivers */\n",
            '#include "measurementd.h"\n',
            "\n/* System */\n",
            '#include "faultHandler.h"\n',
            f'#include "sunspec{self.sunspec_id.value}Interface{self.wrapped.id:>05}.h"\n',
            '#include "math.h"\n',
            '#include "interfaceGen.h"\n',
            "\n\n",
        ]
        c_lines.extend([AUTO_GEN_LINE])

        pre_function_decl = "void {get_set}{base_name} (void) {{\n"
        post_function_decl = "}\n\n"
        declaration = "void {get_set}{base_name} (void);\n"

        if not self.skip_sunspec:
            scale_factor_from_uuid = {}
            for child in self.wrapped.children:
                builder = specific_builders.wrap(
                    wrapped=child,
                    model_id=self.wrapped.id,
                    parameter_uuid_finder=self.parameter_uuid_finder,
                    sunspec_id=self.sunspec_id,
                )
                scale_factor_from_uuid_built = builder.gen_scale_factor()
                scale_factor_from_uuid.update(scale_factor_from_uuid_built)

            for child in self.wrapped.children:
                builder = specific_builders.wrap(
                    wrapped=child,
                    model_id=self.wrapped.id,
                    parameter_uuid_finder=self.parameter_uuid_finder,
                    scale_factor_from_uuid=scale_factor_from_uuid,
                    sunspec_id=self.sunspec_id,
                )

                get_children, set_children, base_decl = builder.gen()

                get_child_flat = list(flatten_list(get_children))
                set_child_flat = list(flatten_list(set_children))
                base_decl_child_flat = list(flatten_list(base_decl))

                all_children = zip(base_decl_child_flat, get_child_flat, set_child_flat)

                for base_child, get_child, set_child in all_children:
                    if get_child:
                        h_lines.extend(
                            declaration.format(base_name=base_child, get_set="get")
                        )
                        c_lines.extend(
                            pre_function_decl.format(
                                base_name=base_child, get_set="get"
                            )
                        )
                        c_lines.extend(
                            [
                                f"    {line.rstrip()}\n"
                                for line in get_child.splitlines()
                            ]
                        )
                        c_lines.extend(post_function_decl)

                    if set_child:
                        h_lines.extend(
                            declaration.format(base_name=base_child, get_set="set")
                        )
                        c_lines.extend(
                            pre_function_decl.format(
                                base_name=base_child, get_set="set"
                            )
                        )
                        c_lines.extend(
                            [
                                f"    {line.rstrip()}\n"
                                for line in set_child.splitlines()
                            ]
                        )
                        c_lines.extend(post_function_decl)

        h_lines.extend([f"\n#endif //{include_guard}\n"])

        with c_file_path.open("w", newline="\n") as f:
            for c_line in c_lines:
                f.write(c_line)

        with h_file_path.open("w", newline="\n") as f:
            for h_line in h_lines:
                f.write(h_line)


@specific_builders(epcpm.sunspecmodel.TableRepeatingBlock)
@attr.s
class SpecificTableRepeatingBlock:
    """Specific model interface generator for the SunSpec TableRepeatingBlock class."""

    wrapped = attr.ib()
    model_id = attr.ib()
    repeating_block_reference = attr.ib(default=None)
    scale_factor_from_uuid = attr.ib(default=None)
    parameter_uuid_finder = attr.ib(default=None)
    sunspec_id = attr.ib(default=None)
    is_table = attr.ib(default=False)
    fixed_block_reference = attr.ib(default=None, type=epcpm.sunspecmodel.FixedBlock)

    def gen(self) -> typing.Tuple[typing.List[str], typing.List[str], typing.List[str]]:
        """
        Specific model interface generator for the SunSpec TableRepeatingBlock class.

        Returns:
            list[str], list[str], list[str]: list of getters, list of setters, list of base declaration strings
        """
        get_out = []
        set_out = []
        base_decl = []

        for child in self.wrapped.children:
            builder = specific_builders.wrap(
                wrapped=child,
                scale_factor_from_uuid=self.scale_factor_from_uuid,
                parameter_uuid_finder=self.parameter_uuid_finder,
                model_id=self.model_id,
                is_table=True,
                sunspec_id=self.sunspec_id,
            )
            get_child, set_child, base_decl_child = builder.gen()

            # Multiply the number of entries by the number of table curves.
            for curve_index in range(self.wrapped.repeats):
                if get_child is not None:
                    get_out.append(
                        get_child.format(
                            table_option="Curve_{:02}".format(curve_index + 1)
                        )
                    )
                else:
                    get_out.append(get_child)
                if set_child is not None:
                    set_out.append(
                        set_child.format(
                            table_option="Curve_{:02}".format(curve_index + 1)
                        )
                    )
                else:
                    set_out.append(set_child)
                base_decl.append(
                    base_decl_child.format(
                        table_option="Curve_{:02}".format(curve_index + 1)
                    )
                )

        return get_out, set_out, base_decl


@specific_builders(epcpm.sunspecmodel.FixedBlock)
@attr.s
class SpecificFixedBlock:
    """Specific model interface generator for the SunSpec FixedBlock class."""

    wrapped = attr.ib()
    model_id = attr.ib()
    repeating_block_reference = attr.ib(default=None)
    scale_factor_from_uuid = attr.ib(default=None)
    parameter_uuid_finder = attr.ib(default=None)
    sunspec_id = attr.ib(default=None)
    is_table = attr.ib(default=False)
    fixed_block_reference = attr.ib(default=None, type=epcpm.sunspecmodel.FixedBlock)

    def gen(self) -> typing.Tuple[typing.List[str], typing.List[str], typing.List[str]]:
        """
        Specific model interface generator for the SunSpec FixedBlock class.

        Returns:
            list[str], list[str], list[str]: list of getters, list of setters, list of base declaration strings
        """
        get_out = []
        set_out = []
        base_decl = []

        for child in self.wrapped.children:
            builder = specific_builders.wrap(
                wrapped=child,
                scale_factor_from_uuid=self.scale_factor_from_uuid,
                parameter_uuid_finder=self.parameter_uuid_finder,
                model_id=self.model_id,
                is_table=False,
                sunspec_id=self.sunspec_id,
            )
            get_child, set_child, base_decl_child = builder.gen()
            get_out.append(get_child)
            set_out.append(set_child)
            base_decl.append(base_decl_child)

        return get_out, set_out, base_decl

    def gen_scale_factor(self):
        scale_factor_from_uuid = epcpm.pm_helper.build_uuid_scale_factor_dict(
            points=self.wrapped.children,
            parameter_uuid_finder=self.parameter_uuid_finder,
        )
        return scale_factor_from_uuid


@specific_builders(epcpm.sunspecmodel.TableBlock)
@attr.s
class SpecificTableBlock:
    """Specific model interface generator for the SunSpec TableBlock class."""

    wrapped = attr.ib()
    model_id = attr.ib()
    repeating_block_reference = attr.ib(default=None)
    scale_factor_from_uuid = attr.ib(default=None)
    parameter_uuid_finder = attr.ib(default=None)
    sunspec_id = attr.ib(default=None)
    is_table = attr.ib(default=False)
    fixed_block_reference = attr.ib(default=None, type=epcpm.sunspecmodel.FixedBlock)

    def gen(self) -> typing.Tuple[typing.List[str], typing.List[str], typing.List[str]]:
        """
        Specific model interface generator for the SunSpec TableBlock class.

        Returns:
            list[str], list[str], list[str]: list of getters, list of setters, list of base declaration strings
        """
        get_out = []
        set_out = []
        base_decl = []

        for curve_index, child in enumerate(self.wrapped.children):
            builder = specific_builders.wrap(
                wrapped=child,
                scale_factor_from_uuid=self.scale_factor_from_uuid,
                parameter_uuid_finder=self.parameter_uuid_finder,
                model_id=self.model_id,
                is_table=True,
                sunspec_id=self.sunspec_id,
            )
            get_child, set_child, base_decl_child = builder.gen()

            get_child_flat = list(flatten_list(get_child))
            set_child_flat = list(flatten_list(set_child))
            base_decl_child_flat = list(flatten_list(base_decl_child))

            for get_child_item in get_child_flat:
                if get_child_item is not None:
                    modified_get_child_item = self._allow_format_for_table_option(
                        get_child_item
                    )
                    get_out.append(
                        modified_get_child_item.format(
                            table_option="Curve_{:02}".format(curve_index + 1)
                        )
                    )
                else:
                    get_out.append(get_child_item)

            for set_child_item in set_child_flat:
                if set_child_item is not None:
                    modified_set_child_item = self._allow_format_for_table_option(
                        set_child_item
                    )
                    set_out.append(
                        modified_set_child_item.format(
                            table_option="Curve_{:02}".format(curve_index + 1)
                        )
                    )
                else:
                    set_out.append(set_child_item)

            for base_decl_item in base_decl_child_flat:
                base_decl.append(
                    base_decl_item.format(
                        table_option="Curve_{:02}".format(curve_index + 1)
                    )
                )

        return get_out, set_out, base_decl

    def gen_scale_factor(self):
        return {}

    @staticmethod
    def _allow_format_for_table_option(str_with_table_option: str) -> str:
        """
        When there are multiple lines of code, handle the table_option with these regex's
        so that the curly braces don't set off the python string format.

        Args:
            str_with_table_option: string that contains one or more 'table_option' substrings

        Returns:
            str: modified string with added curly braces except for around table_option substring(s)
        """
        modified_str = re.sub("(?!{table_option){", "{{", str_with_table_option)
        modified_str = re.sub("(?<!table_option)}", "}}", modified_str)
        return modified_str


@specific_builders(epcpm.sunspecmodel.TableGroup)
@attr.s
class SpecificTableGroup:
    """Specific model interface generator for the SunSpec TableGroup class."""

    wrapped = attr.ib()
    model_id = attr.ib()
    repeating_block_reference = attr.ib(default=None)
    scale_factor_from_uuid = attr.ib(default=None)
    parameter_uuid_finder = attr.ib(default=None)
    sunspec_id = attr.ib(default=None)
    is_table = attr.ib(default=False)
    fixed_block_reference = attr.ib(default=None, type=epcpm.sunspecmodel.FixedBlock)

    def gen(self) -> typing.Tuple[typing.List[str], typing.List[str], typing.List[str]]:
        """
        Specific model interface generator for the SunSpec TableGroup class.

        Returns:
            list[str], list[str], list[str]: list of getters, list of setters, list of base declaration strings
        """
        get_out = []
        set_out = []
        base_decl = []

        for child in self.wrapped.children:
            builder = specific_builders.wrap(
                wrapped=child,
                scale_factor_from_uuid=self.scale_factor_from_uuid,
                parameter_uuid_finder=self.parameter_uuid_finder,
                model_id=self.model_id,
                is_table=self.is_table,
                sunspec_id=self.sunspec_id,
            )
            get_child, set_child, base_decl_child = builder.gen()
            get_out.append(get_child)
            set_out.append(set_child)
            base_decl.append(base_decl_child)

        return get_out, set_out, base_decl


@specific_builders(epcpm.sunspecmodel.HeaderBlock)
@attr.s
class SpecificHeaderBlock:
    """Specific model interface generator for the SunSpec HeaderBlock class."""

    wrapped = attr.ib()
    model_id = attr.ib()
    repeating_block_reference = attr.ib(default=None)
    scale_factor_from_uuid = attr.ib(default=None)
    parameter_uuid_finder = attr.ib(default=None)
    sunspec_id = attr.ib(default=None)
    fixed_block_reference = attr.ib(default=None, type=epcpm.sunspecmodel.FixedBlock)

    def gen(self) -> typing.Tuple[typing.List[str], typing.List[str], typing.List[str]]:
        """
        Specific model interface generator for the SunSpec HeaderBlock class.

        Returns:
            list[str], list[str], list[str]: list of getters, list of setters, list of base declaration strings
        """
        return [], [], []

    def gen_scale_factor(self):
        return {}


@specific_builders(epcpm.sunspecmodel.TableRepeatingBlockReference)
@attr.s
class SpecificTableRepeatingBlockReference:
    """Specific model interface generator for the SunSpec TableRepeatingBlockReference class."""

    wrapped = attr.ib()
    model_id = attr.ib()
    scale_factor_from_uuid = attr.ib(default=None)
    parameter_uuid_finder = attr.ib(default=None)
    sunspec_id = attr.ib(default=None)
    is_table = attr.ib(default=False)
    fixed_block_reference = attr.ib(default=None, type=epcpm.sunspecmodel.FixedBlock)

    def gen(self) -> typing.Tuple[typing.List[str], typing.List[str], typing.List[str]]:
        """
        Specific model interface generator for the SunSpec TableRepeatingBlockReference class.

        Returns:
            list[str], list[str], list[str]: list of getters, list of setters, list of base declaration strings
        """
        builder = specific_builders.wrap(
            wrapped=self.wrapped.original,
            parameter_uuid_finder=self.parameter_uuid_finder,
            model_id=self.model_id,
            is_table=self.is_table,
            repeating_block_reference=self.wrapped,
            sunspec_id=self.sunspec_id,
        )

        return builder.gen()

    def gen_scale_factor(self):
        return {}


@specific_builders(epcpm.sunspecmodel.DataPoint)
@attr.s
class SpecificDataPoint:
    """Specific model interface generator for the SunSpec DataPoint class."""

    wrapped = attr.ib()
    scale_factor_from_uuid = attr.ib()
    model_id = attr.ib()
    is_table = attr.ib()
    parameter_uuid_finder = attr.ib(default=None)
    sunspec_id = attr.ib(default=None)

    def gen(self) -> typing.Tuple[typing.List[str], typing.List[str], str]:
        """
        Specific model interface generator for the SunSpec DataPoint class.

        Returns:
            list[str], list[str], str: list of getters, list of setters, base declaration string
        """
        get_out = None
        set_out = None
        base_decl = None

        if self.wrapped.parameter_uuid is not None:
            parameter = self.parameter_uuid_finder(self.wrapped.parameter_uuid)

            meta = "[Meta_Value]"

            getter = []
            setter = []

            uses_interface_item = (
                isinstance(parameter, epyqlib.pm.parametermodel.Parameter)
                and parameter.uses_interface_item()
            )

            hand_coded_getter_function_name = getter_name(
                parameter=parameter,
                sunspec_id=self.sunspec_id,
                model_id=self.model_id,
                is_table=self.is_table,
            )

            hand_coded_setter_function_name = setter_name(
                parameter=parameter,
                sunspec_id=self.sunspec_id,
                model_id=self.model_id,
                is_table=self.is_table,
            )

            if self.wrapped.factor_uuid is not None:
                scale_factor = self.parameter_uuid_finder(
                    self.scale_factor_from_uuid[self.wrapped.factor_uuid].parameter_uuid
                ).abbreviation
            else:
                scale_factor = None

            if not uses_interface_item and not self.wrapped.not_implemented:
                if scale_factor is not None:
                    scale_factor_updater_prefix = get_point_name_prefix(
                        self.sunspec_id, self.model_id
                    )
                    scale_factor_updater_name = (
                        f"get{scale_factor_updater_prefix}{scale_factor}();"
                    )
                    getter.append(scale_factor_updater_name)
                    setter.append(scale_factor_updater_name)

                getter.append(f"{hand_coded_getter_function_name}();")

            sunspec_model_variable = (
                f"sunspec{self.sunspec_id.value}Interface.model{self.model_id}"
            )

            if self.is_table:
                table_option = "{table_option}_"
            else:
                table_option = ""

            sunspec_variable = (
                f"{sunspec_model_variable}.{table_option}{parameter.abbreviation}"
            )

            if self.wrapped.type_uuid is not None:
                point_type = self.parameter_uuid_finder(self.wrapped.type_uuid).name
            else:
                point_type = "NOT_ASSIGNED"

            if point_type == "pad":
                getter.append(f"{sunspec_variable} = 0x8000;")
            elif self.wrapped.not_implemented:
                value = {
                    "int16": "INT16_C(0x8000)",
                    "uint16": "UINT16_C(0xffff)",
                    "acc16": "UINT16_C(0x0000)",
                    "enum16": "UINT16_C(0xffff)",
                    "bitfield16": "UINT16_C(0xffff)",
                    "int32": "sunspecInt32ToSS32_returns(INT32_C(0x80000000))",
                    "uint32": "sunspecUint32ToSSU32_returns(UINT32_C(0xffffffff))",
                    "acc32": "sunspecUint32ToSSU32_returns(UINT32_C(0x00000000))",
                    "enum32": "sunspecUint32ToSSU32_returns(UINT32_C(0xffffffff))",
                    "bitfield32": "sunspecUint32ToSSU32_returns(UINT32_C(0xffffffff))",
                    "ipaddr": "sunspecUint32ToSSU32_returns(UINT32_C(0x00000000))",
                    "int64": "sunspecInt64ToSS64_returns(INT64_C(0x8000000000000000))",
                    "uint64": "sunspecUint64ToSSU64_returns(UINT64_C(0xffffffffffffffff))",
                    # yes, acc64 seems to be an int64, not a uint64
                    "acc64": "sunspecInt64ToSS64_returns(INT64_C(0x0000000000000000))",
                    # 'ipv6addr': 'INT128_C(0x00000000000000000000000000000000)',
                    # 'float32': 'NAN',
                    "sunssf": "INT16_C(0x8000)",
                    "string": "UINT16_C(0x0000)",
                }[point_type]
                if point_type == "string":
                    getter.extend(
                        [
                            f"for (size_t i = 0; i < LENGTHOF({sunspec_variable}); i++) {{",
                            [f"{sunspec_variable}[i] = {value};"],
                            "}",
                        ]
                    )
                elif point_type.startswith("bitfield"):
                    getter.append(f"{sunspec_variable}.raw = {value};")
                    # # below because parsesunspec only detects bitfields
                    # # if they have values
                    # if self.wrapped.enumeration_uuid is not None:
                    #     getter.append(
                    #         f'{sunspec_variable}.raw = {value};'
                    #     )
                    # else:
                    #     getter.append(
                    #         f'*((uint{row.type[-2:]}_t*) &{sunspec_variable})'
                    #         f' = {value};'
                    #     )
                else:
                    getter.append(f"{sunspec_variable} = {value};")

                setter.append("// point not implemented, do nothing")
            elif parameter.nv_format is not None:
                internal_variable = parameter.nv_format.format(meta)

                # TODO: CAMPid 075780541068182645821856068542023499
                converter = {
                    "uint32": {
                        "get": "sunspecUint32ToSSU32",
                        "set": "sunspecSSU32ToUint32",
                    },
                    "int32": {
                        # TODO: add this to embedded?
                        # 'get': 'sunspecInt32ToSSS32',
                        "set": "sunspecSSS32ToInt32",
                    },
                }.get(point_type)

                if converter is not None:
                    get_converter = converter["get"]
                    set_converter = converter["set"]

                    get_cast = ""
                    set_cast = ""
                    if parameter.nv_cast:
                        set_cast = f"(__typeof__({internal_variable})) "
                        get_type = {
                            "uint32": "uint32_t",
                        }[point_type]
                        get_cast = f"({get_type})"

                    getter.extend(
                        [
                            f"{get_converter}(",
                            [
                                f"&{sunspec_variable},",
                                f"{get_cast}{internal_variable}",
                            ],
                            ");",
                        ]
                    )
                    setter.extend(
                        [
                            f"{internal_variable} = {set_cast}{set_converter}(",
                            [
                                f"&{sunspec_variable}",
                            ],
                            ");",
                        ]
                    )
                else:
                    getter.append(
                        adjust_assignment(
                            left_hand_side=sunspec_variable,
                            right_hand_side=internal_variable,
                            sunspec_model_variable=sunspec_model_variable,
                            scale_factor=self.wrapped.scale_factor,
                            internal_scale=parameter.internal_scale_factor,
                            parameter=parameter,
                            factor_operator="*",
                        )
                    )

                    setter.append(
                        adjust_assignment(
                            left_hand_side=internal_variable,
                            right_hand_side=sunspec_variable,
                            sunspec_model_variable=sunspec_model_variable,
                            scale_factor=self.wrapped.scale_factor,
                            internal_scale=parameter.internal_scale_factor,
                            parameter=parameter,
                            factor_operator="/",
                        )
                    )

            elif uses_interface_item:
                parameter_uuid = epcpm.pm_helper.convert_uuid_to_variable_name(
                    parameter.uuid
                )
                item_name = f"interfaceItem_{parameter_uuid}"

                getter.extend(
                    [
                        f"{item_name}.common.sunspec{self.sunspec_id.value}.getter(",
                        [
                            f"(InterfaceItem_void *) &{item_name},",
                            f"Meta_Value",
                        ],
                        f");",
                    ]
                )
                setter.extend(
                    [
                        f"{item_name}.common.sunspec{self.sunspec_id.value}.setter(",
                        [
                            f"(InterfaceItem_void *) &{item_name},",
                            f"true,",
                            f"Meta_Value",
                        ],
                        f");",
                    ]
                )
            else:
                if getattr(parameter, "sunspec_getter", None) is not None:
                    getter.append(
                        parameter.sunspec_getter.format(
                            interface=sunspec_variable,
                        )
                    )

                if getattr(parameter, "sunspec_setter", None) is not None:
                    setter.append(
                        parameter.sunspec_setter.format(
                            interface=sunspec_variable,
                        )
                    )

            get_out = epcpm.c.format_nested_lists(getter)

            if not uses_interface_item and not self.wrapped.not_implemented:
                setter.append(f"{hand_coded_setter_function_name}();")

            if not parameter.read_only:
                set_out = epcpm.c.format_nested_lists(setter)
            else:
                set_out = None

            base_decl_prefix = get_point_name_prefix(self.sunspec_id, self.model_id)
            base_decl = f"{base_decl_prefix}{table_option}{parameter.abbreviation}"

        return get_out, set_out, base_decl


@specific_builders(epcpm.sunspecmodel.DataPointBitfield)
@attr.s
class SpecificDataPointBitfield:
    """Specific model interface generator for the SunSpec DataPointBitfield class."""

    wrapped = attr.ib()
    scale_factor_from_uuid = attr.ib()
    model_id = attr.ib()
    is_table = attr.ib()
    parameter_uuid_finder = attr.ib(default=None)
    sunspec_id = attr.ib(default=None)

    def gen(self) -> typing.Tuple[typing.List[str], typing.List[str], str]:
        """
        Specific model interface generator for the SunSpec DataPointBitfield class.

        Returns:
            list[str], list[str], str: list of getters, list of setters, base declaration string
        """
        getter = []
        setter = []

        if self.wrapped.parameter_uuid is not None:
            parameter = self.parameter_uuid_finder(self.wrapped.parameter_uuid)

        uses_interface_item = (
            isinstance(parameter, epyqlib.pm.parametermodel.Parameter)
            and parameter.uses_interface_item()
        )

        if uses_interface_item:
            parameter_uuid = epcpm.pm_helper.convert_uuid_to_variable_name(
                parameter.uuid
            )
            item_name = f"interfaceItem_{parameter_uuid}"

            getter.extend(
                [
                    f"{item_name}.common.sunspec{self.sunspec_id.value}.getter(",
                    [
                        f"(InterfaceItem_void *) &{item_name},",
                        f"Meta_Value",
                    ],
                    f");",
                ]
            )
            setter.extend(
                [
                    f"{item_name}.common.sunspec{self.sunspec_id.value}.setter(",
                    [
                        f"(InterfaceItem_void *) &{item_name},",
                        f"true,",
                        f"Meta_Value",
                    ],
                    f");",
                ]
            )

        if len(getter) > 0:
            get_out = epcpm.c.format_nested_lists(getter)

        if not parameter.read_only:
            set_out = epcpm.c.format_nested_lists(setter)
        else:
            set_out = None

        base_decl_prefix = get_point_name_prefix(self.sunspec_id, self.model_id)
        base_decl = f"{base_decl_prefix}{parameter.abbreviation}"

        return get_out, set_out, base_decl


@enumeration_builders(epcpm.sunspecmodel.HeaderBlock)
@attr.s
class EnumerationHeaderBlock:
    """Enumeration interface generator for the SunSpec HeaderBlock class."""

    wrapped = attr.ib()
    model_id = attr.ib()
    parameter_uuid_finder = attr.ib(default=None)
    sunspec_id = attr.ib(default=None)

    def gen(
        self,
    ) -> typing.Tuple[
        typing.List[str], typing.Dict[str, epyqlib.pm.parametermodel.SunSpecEnumerator]
    ]:
        """
        Enumeration interface generator for the SunSpec HeaderBlock class.

        Returns:
            [list[str], dict[str, SunSpecEnumerator]: list of output, dict of SunSpecEnumerator's
        """
        return [], {}


@enumeration_builders(epcpm.sunspecmodel.FixedBlock)
@enumeration_builders(epcpm.sunspecmodel.TableRepeatingBlockReference)
@enumeration_builders(epcpm.sunspecmodel.TableBlock)
@enumeration_builders(epcpm.sunspecmodel.TableGroup)
@attr.s
class EnumerationBlock:
    """Enumeration interface generator for the SunSpec FixedBlock, TableRepeatingBlockReference, TableBlock, TableGroup classes."""

    wrapped = attr.ib()
    model_id = attr.ib()
    parameter_uuid_finder = attr.ib(default=None)
    sunspec_id = attr.ib(default=None)

    def gen(
        self,
    ) -> typing.Tuple[
        typing.List[str], typing.Dict[str, epyqlib.pm.parametermodel.SunSpecEnumerator]
    ]:
        """
        Enumeration interface generator for the SunSpec FixedBlock, TableRepeatingBlockReference, TableBlock,
        TableGroup classes.

        Returns:
            [list[str], dict[str, SunSpecEnumerator]: list of output, dict of SunSpecEnumerator's
        """
        rows_out = []
        default_enumerator_dict = dict()
        for child in self.wrapped.children:
            enumeration_builder = enumeration_builders.wrap(
                wrapped=child,
                model_id=self.model_id,
                parameter_uuid_finder=self.parameter_uuid_finder,
                sunspec_id=self.sunspec_id,
            )
            rows_built, default_enumerator = enumeration_builder.gen()
            rows_out.extend(rows_built)
            default_enumerator_dict.update(default_enumerator)

        return rows_out, default_enumerator_dict


@enumeration_builders(
    epcpm.sunspecmodel.TableRepeatingBlockReferenceDataPointReference,
)
@attr.s
class EnumerationTableRepeatingBlockReferenceDataPointReference:
    """Enumeration interface generator for the SunSpec TableRepeatingBlockReferenceDataPointReference class."""

    wrapped = attr.ib()
    model_id = attr.ib()
    parameter_uuid_finder = attr.ib(default=None)
    sunspec_id = attr.ib(default=None)

    def gen(
        self,
    ) -> typing.Tuple[
        typing.List[str], typing.Dict[str, epyqlib.pm.parametermodel.SunSpecEnumerator]
    ]:
        """
        Enumeration interface generator for the SunSpec TableRepeatingBlockReferenceDataPointReference class.

        Returns:
            [list[str], dict[str, SunSpecEnumerator]: list of output, dict of SunSpecEnumerator's
        """
        enumeration_builder = enumeration_builders.wrap(
            wrapped=self.wrapped.original,
            model_id=self.model_id,
            parameter_uuid_finder=self.parameter_uuid_finder,
            sunspec_id=self.sunspec_id,
        )
        return enumeration_builder.gen()


@enumeration_builders(epcpm.sunspecmodel.DataPoint)
@attr.s
class EnumerationDataPoint:
    """Enumeration interface generator for the SunSpec DataPoint class."""

    wrapped = attr.ib()
    model_id = attr.ib()
    parameter_uuid_finder = attr.ib(default=None)
    sunspec_id = attr.ib(default=None)

    def gen(
        self,
    ) -> typing.Tuple[
        typing.List[str], typing.Dict[str, epyqlib.pm.parametermodel.SunSpecEnumerator]
    ]:
        """
        Enumeration interface generator for the SunSpec DataPoint class.

        Returns:
            [list[str], dict[str, SunSpecEnumerator]: list of output, dict of SunSpecEnumerator's
        """
        rows_out = []
        default_enumerator = dict()

        parameter = self.parameter_uuid_finder(self.wrapped.parameter_uuid)

        sunspec_type = self.parameter_uuid_finder(self.wrapped.type_uuid).name

        enumeration_uuid = getattr(self.wrapped, "enumeration_uuid", None)
        if enumeration_uuid is None:
            if sunspec_type == "bitfield16":
                rows_out.append("typedef struct\n{\n")
                rows_out.append("    uint16_t unused:16;\n")
                rows_out.append(
                    f"}} Sunspec{self.sunspec_id.value}Model{self.model_id}_{parameter.abbreviation};\n\n"
                )

                rows_out.extend(
                    _output_typedef_union(
                        self.sunspec_id,
                        self.model_id,
                        sunspec_type,
                        parameter.abbreviation,
                    )
                )
                return rows_out, default_enumerator

            elif sunspec_type == "bitfield32":
                rows_out.append("typedef struct\n{\n")
                rows_out.append("    uint16_t unusedHi:16;\n")
                rows_out.append("    uint16_t unused:16;\n")
                rows_out.append(
                    f"}} Sunspec{self.sunspec_id.value}Model{self.model_id}_{parameter.abbreviation};\n\n"
                )

                rows_out.extend(
                    _output_typedef_union(
                        self.sunspec_id,
                        self.model_id,
                        sunspec_type,
                        parameter.abbreviation,
                    )
                )
                return rows_out, default_enumerator

            elif sunspec_type == "enum16":
                rows_out.append("typedef enum\n{\n")
                rows_out.append(
                    f"    Sunspec{self.sunspec_id.value}Model{self.model_id}_{parameter.abbreviation}_EMPTY_ENUMERATION_FILLER,\n"
                )
                rows_out.append(
                    f"}} Sunspec{self.sunspec_id.value}Model{self.model_id}_{parameter.abbreviation};\n\n"
                )
                return rows_out, default_enumerator

            return rows_out, default_enumerator

        enumeration = self.parameter_uuid_finder(enumeration_uuid)

        enumerators_by_bit = {
            enumerator.value: enumerator for enumerator in enumeration.children
        }

        return _output_enum_or_bitfield(
            self.wrapped.size,
            self.sunspec_id,
            self.model_id,
            sunspec_type,
            enumerators_by_bit,
            parameter,
        )


@enumeration_builders(epcpm.sunspecmodel.DataPointBitfield)
@attr.s
class EnumerationDataPointBitfield:
    """Enumeration interface generator for the SunSpec DataPointBitfield class."""

    wrapped = attr.ib()
    model_id = attr.ib()
    parameter_uuid_finder = attr.ib(default=None)
    sunspec_id = attr.ib(default=None)

    def gen(
        self,
    ) -> typing.Tuple[
        typing.List[str], typing.Dict[str, epyqlib.pm.parametermodel.SunSpecEnumerator]
    ]:
        """
        Enumeration interface generator for the SunSpec DataPointBitfield class.

        Returns:
            [list[str], dict[str, SunSpecEnumerator]: list of output, dict of SunSpecEnumerator's
        """
        parameter = self.parameter_uuid_finder(self.wrapped.parameter_uuid)

        sunspec_type = self.parameter_uuid_finder(self.wrapped.type_uuid).name

        # 16 bits per register
        total_bit_count = self.wrapped.size * 16
        decimal_digits = len(str(total_bit_count - 1))

        enumerators_by_bit = {}
        bit = 0
        for child in self.wrapped.children:
            child_parameter = self.parameter_uuid_finder(child.parameter_uuid)

            if child.bit_length > 1:
                for child_bit in range(child.bit_length):
                    padded_bit_string = f"{child_bit:0{decimal_digits}}"
                    enumerator = epyqlib.pm.parametermodel.SunSpecEnumerator(
                        abbreviation=f"{child_parameter.abbreviation}{padded_bit_string}",
                        value=bit,
                    )
                    enumerators_by_bit[bit] = enumerator
                    bit += 1
            else:
                enumerator = epyqlib.pm.parametermodel.SunSpecEnumerator(
                    abbreviation=f"{child_parameter.abbreviation}",
                    value=bit,
                )
                enumerators_by_bit[bit] = enumerator
                bit += 1

        return _output_enum_or_bitfield(
            self.wrapped.size,
            self.sunspec_id,
            self.model_id,
            sunspec_type,
            enumerators_by_bit,
            parameter,
        )


def _output_enum_or_bitfield(
    size: int,
    sunspec_id: epcpm.pm_helper.SunSpecSection,
    model_id: int,
    sunspec_type: str,
    enumerators_by_bit: typing.Dict[int, epyqlib.pm.parametermodel.SunSpecEnumerator],
    parameter: epyqlib.pm.parametermodel.Parameter,
) -> typing.Tuple[
    typing.List[str], typing.Dict[str, epyqlib.pm.parametermodel.SunSpecEnumerator]
]:
    """
    Common code for enumeration interface generator.

    Args:
        size: size of the bitfield (1 or 2)
        sunspec_id: SunSpec section internal identifier
        model_id: model ID
        sunspec_type: SunSpec type to be converted to C type
        enumerators_by_bit: dict of bit to enumerator object
        parameter: parameter for the enumeration

    Returns:
        list[str], dict[str, SunSpecEnumerator: list of output, dict of SunSpecEnumerator's
    """
    rows_out = []
    default_enumerator = {}

    # 16 bits per register
    total_bit_count = size * 16
    decimal_digits = len(str(total_bit_count - 1))

    if sunspec_type == "enum16":
        rows_out.append("typedef enum\n{\n")

        for bit in range(total_bit_count):
            enumerator = enumerators_by_bit.get(bit)
            if enumerator is None:
                padded_bit_string = f"{bit:0{decimal_digits}}"
                enumerator = epyqlib.pm.parametermodel.SunSpecEnumerator(
                    label=f"Reserved - {padded_bit_string}",
                    name=f"Rsvd{padded_bit_string}",
                    value=bit,
                )
                row_out = f"    SUNSPEC{sunspec_id.value}MODEL{model_id}_{parameter.abbreviation.upper()}_{enumerator.name} = {bit},\n"
            else:
                if enumerator.abbreviation:
                    enumerator_name_out = enumerator.abbreviation
                else:
                    enumerator_name_out = enumerator.name
                row_out = f"    SUNSPEC{sunspec_id.value}MODEL{model_id}_{parameter.abbreviation.upper()}_{enumerator_name_out} = {bit},\n"
            if bit == 0:
                default_enumerator[parameter.abbreviation] = enumerator

            rows_out.append(row_out)

        rows_out.append(
            f"}} Sunspec{sunspec_id.value}Model{model_id}_{parameter.abbreviation};\n\n"
        )

    elif sunspec_type == "bitfield16":
        rows_out.append("typedef struct\n{\n")

        for bit in range(total_bit_count):
            enumerator = enumerators_by_bit.get(bit)
            if enumerator is None:
                padded_bit_string = f"{bit:0{decimal_digits}}"
                enumerator = epyqlib.pm.parametermodel.SunSpecEnumerator(
                    label=f"Reserved - {padded_bit_string}",
                    name=f"Rsvd{padded_bit_string}",
                    value=bit,
                )
                row_out = f"    uint16_t {enumerator.name}:1;\n"
            else:
                if enumerator.abbreviation:
                    enumerator_name_out = enumerator.abbreviation
                else:
                    enumerator_name_out = enumerator.name
                row_out = f"    uint16_t {enumerator_name_out}:1;\n"

            rows_out.append(row_out)

        rows_out.append(
            f"}} Sunspec{sunspec_id.value}Model{model_id}_{parameter.abbreviation};\n\n"
        )

        rows_out.extend(
            _output_typedef_union(
                sunspec_id, model_id, sunspec_type, parameter.abbreviation
            )
        )

    elif sunspec_type == "bitfield32":
        rows_out.append("typedef struct\n{\n")

        for bit in range(16, total_bit_count):
            enumerator = enumerators_by_bit.get(bit)
            if enumerator is None:
                padded_bit_string = f"{bit:0{decimal_digits}}"
                enumerator = epyqlib.pm.parametermodel.SunSpecEnumerator(
                    label=f"Reserved - {padded_bit_string}",
                    name=f"Rsvd{padded_bit_string}",
                    value=bit,
                )
                row_out = f"    uint16_t {enumerator.name}:1;\n"
            else:
                if enumerator.abbreviation:
                    enumerator_name_out = enumerator.abbreviation
                else:
                    enumerator_name_out = enumerator.name
                row_out = f"    uint16_t {enumerator_name_out}:1;\n"

            rows_out.append(row_out)

        for bit in range(0, 16):
            enumerator = enumerators_by_bit.get(bit)
            if enumerator is None:
                padded_bit_string = f"{bit:0{decimal_digits}}"
                enumerator = epyqlib.pm.parametermodel.SunSpecEnumerator(
                    label=f"Reserved - {padded_bit_string}",
                    name=f"Rsvd{padded_bit_string}",
                    value=bit,
                )
                row_out = f"    uint16_t {enumerator.name}:1;\n"
            else:
                if enumerator.abbreviation:
                    enumerator_name_out = enumerator.abbreviation
                else:
                    enumerator_name_out = enumerator.name
                row_out = f"    uint16_t {enumerator_name_out}:1;\n"

            rows_out.append(row_out)

        rows_out.append(
            f"}} Sunspec{sunspec_id.value}Model{model_id}_{parameter.abbreviation};\n\n"
        )

        rows_out.extend(
            _output_typedef_union(
                sunspec_id, model_id, sunspec_type, parameter.abbreviation
            )
        )

    return rows_out, default_enumerator


def _output_typedef_union(
    sunspec_id: epcpm.pm_helper.SunSpecSection,
    model_id: int,
    sunspec_type: str,
    parameter_abbreviation: str,
) -> typing.List[str]:
    """
    Common code for enumeration interface generator.
    Specifically generation of typedef union code section.

    Args:
        sunspec_id: SunSpec section internal identifier
        model_id: model ID
        sunspec_type: SunSpec type to be converted to C type
        parameter_abbreviation: parameter abbreviation string

    Returns:
        list[str]: output C typedef union
    """
    rows_out = []
    raw_type = sunspec_types[sunspec_type]
    rows_out.append("typedef union\n{\n")
    rows_out.append(
        f"    Sunspec{sunspec_id.value}Model{model_id}_{parameter_abbreviation} fields;\n"
    )
    rows_out.append(f"    {raw_type} raw;\n")
    rows_out.append(
        f"}} Sunspec{sunspec_id.value}Model{model_id}_{parameter_abbreviation}_u;\n\n"
    )
    return rows_out


def adjust_assignment(
    left_hand_side,
    right_hand_side,
    sunspec_model_variable,
    scale_factor,
    internal_scale,
    parameter,
    factor_operator,
):
    if scale_factor is not None:
        scale_factor_variable = f"{sunspec_model_variable}.{scale_factor}"
        # TODO: what about positive scalings?
        # factor = f'(P99_IPOW(-{scale_factor_variable}, 10))'
        # TODO: we really don't want doubles here, do we?
        # factor = f'(pow(10, -{scale_factor_variable}))'

        opposite = "" if factor_operator == "*" else "-"

        right_hand_side = (
            f"(sunspecScale({right_hand_side},"
            f" {opposite}({scale_factor_variable} + {internal_scale})))"
        )

    if parameter.nv_cast:
        right_hand_side = f"((__typeof__({left_hand_side})) {right_hand_side})"

    result = f"{left_hand_side} = {right_hand_side};"

    return result


def getter_setter_name(get_set, parameter, sunspec_id, model_id, is_table):
    if is_table:
        table_option = "_{table_option}"
    else:
        table_option = ""

    format_string = (
        "{get_set}Sunspec{sunspec_id}Model{model_id}{table_option}_{abbreviation}"
    )

    return format_string.format(
        get_set=get_set,
        sunspec_id=sunspec_id.value,
        model_id=model_id,
        abbreviation=parameter.abbreviation,
        table_option=table_option,
    )


def getter_name(parameter, sunspec_id, model_id, is_table):
    return getter_setter_name(
        get_set="get",
        parameter=parameter,
        sunspec_id=sunspec_id,
        model_id=model_id,
        is_table=is_table,
    )


def setter_name(parameter, sunspec_id, model_id, is_table):
    return getter_setter_name(
        get_set="set",
        parameter=parameter,
        sunspec_id=sunspec_id,
        model_id=model_id,
        is_table=is_table,
    )
